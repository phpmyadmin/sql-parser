<?php

declare(strict_types=1);

namespace PhpMyAdmin\SqlParser\Tests;

use PhpMyAdmin\SqlParser\Context;
use PhpMyAdmin\SqlParser\Exceptions\LexerException;
use PhpMyAdmin\SqlParser\Exceptions\ParserException;
use PhpMyAdmin\SqlParser\Lexer;
use PhpMyAdmin\SqlParser\Parser;
use PhpMyAdmin\SqlParser\Token;
use PhpMyAdmin\SqlParser\TokensList;
use PHPUnit\Framework\TestCase as BaseTestCase;

use function file_get_contents;
use function json_encode;
use function str_contains;
use function strpos;
use function substr;

use const JSON_PRESERVE_ZERO_FRACTION;
use const JSON_PRETTY_PRINT;
use const JSON_UNESCAPED_SLASHES;
use const JSON_UNESCAPED_UNICODE;

/**
 * Implements useful methods for testing.
 */
abstract class TestCase extends BaseTestCase
{
    public function setUp(): void
    {
        global $lang;
        // This line makes sure the test suite uses English so we can assert
        // on the error messages, if it is not here you will need to use
        // LC_ALL=C ./vendor/bin/phpunit
        // Users can have French language as default on their OS
        // That would make the assertions fail
        $lang = 'en';
        Context::load();
    }

    /**
     * Gets the token list generated by lexing this query.
     *
     * @param string $query the query to be lexed
     */
    public function getTokensList(string $query): TokensList
    {
        $lexer = new Lexer($query);

        return $lexer->list;
    }

    /**
     * Gets the errors as an array.
     *
     * @param Lexer|Parser $obj object containing the errors
     *
     * @return array<int, array<int, Token|string|int>>
     * @psalm-return (
     *     $obj is Lexer
     *     ? list<array{string, string, int, int}>
     *     : list<array{string, Token|null, int}>
     * )
     */
    public function getErrorsAsArray($obj): array
    {
        $ret = [];
        if ($obj instanceof Lexer) {
            /** @var LexerException $err */
            foreach ($obj->errors as $err) {
                $ret[] = [$err->getMessage(), $err->ch, $err->pos, (int) $err->getCode()];
            }
        } elseif ($obj instanceof Parser) {
            /** @var ParserException $err */
            foreach ($obj->errors as $err) {
                $ret[] = [$err->getMessage(), $err->token, (int) $err->getCode()];
            }
        }

        return $ret;
    }

    /**
     * Runs a test.
     *
     * @param string $name the name of the test
     */
    public function runParserTest(string $name): void
    {
        $sql = file_get_contents('tests/data/' . $name . '.in');
        self::assertIsString($sql);

        if (str_contains($name, '/ansi/')) {
            // set mode if appropriate
            Context::setMode(Context::SQL_MODE_ANSI_QUOTES);
        }

        $mariaDbPos = strpos($name, '_mariadb_');
        if ($mariaDbPos !== false) {// Keep in sync with TestGenerator.php
            // set context
            $mariaDbVersion = (int) substr($name, $mariaDbPos + 9, 6);
            Context::load('MariaDb' . $mariaDbVersion);
        } else {
            Context::load('');
        }

        // Lexer.
        $lexer = new Lexer($sql);
        $lexerErrors = $this->getErrorsAsArray($lexer);
        $lexer->errors = [];

        // Parser.
        $parser = str_contains($name, 'lex') ? null : new Parser($lexer->list);
        $parserErrors = [];
        if ($parser !== null) {
            $parserErrors = $this->getErrorsAsArray($parser);
            $parser->errors = [];
        }

        $encoded = (string) json_encode(
            [
                'query' => $sql,
                'lexer' => $lexer,
                'parser' => $parser,
                'errors' => ['lexer' => $lexerErrors, 'parser' => $parserErrors],
            ],
            JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION | JSON_UNESCAPED_SLASHES
        );

        self::assertJsonStringEqualsJsonFile('tests/data/' . $name . '.out', $encoded);

        // reset mode after test run
        Context::setMode();
    }
}
